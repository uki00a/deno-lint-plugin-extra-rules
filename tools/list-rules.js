// @ts-check
/**
 * TODO: Consider using [@deno/doc](https://jsr.io/@deno/doc) instead of `deno doc --json`.
 *
 * @typedef {{ name: string, categories: Array<string>, description: string }} LintRule
 */
async function main() {
  const docResult = await new Deno.Command(
    "deno",
    {
      args: [
        "doc",
        "--json",
        new URL(import.meta.resolve("../plugin.ts")).pathname,
      ],
    },
  ).output();
  const decoder = new TextDecoder();
  if (docResult.code !== 0) {
    throw new Error(decoder.decode(docResult.stderr));
  }

  /**
   * @typedef {{ kind: "category", doc: string }} CategoryJSDocTag
   * @typedef {{ kind: "unsupported", value: string }} UnsupportedJSDocTag
   * @typedef {CategoryJSDocTag | UnsupportedJSDocTag} JSDocTag
   * @typedef {{ tags: Array<JSDocTag> }} JSDoc
   * @typedef {{ name: string, jsDoc: JSDoc }} InterfaceProperty
   * @typedef {{ properties: Array<InterfaceProperty> }} InterfaceDef
   * @typedef {{ name: string, interfaceDef: InterfaceDef }} InterfaceDocNode
   * @type {{ nodes: Array<InterfaceDocNode> }}
   */
  const docs = JSON.parse(decoder.decode(docResult.stdout));
  const lintRulesNode = docs.nodes.find((x) => x.name === "LintRules");
  if (lintRulesNode == null) {
    throw new Error("Could not find `LintRules` type");
  }

  /** @type {Array<LintRule>} */
  const rules = [];
  for (const property of lintRulesNode.interfaceDef.properties) {
    const descriptionTag = property.jsDoc.tags.find((tag) =>
      tag.kind === "unsupported" && tag.value.startsWith("@description")
    );
    if (descriptionTag?.kind !== "unsupported") {
      throw new Error(
        `"${property.name}" rule should have \`@description\` tag`,
      );
    }
    const description = stripPrefix(descriptionTag.value, "@description")
      .trim();

    const categoryTag = property.jsDoc.tags.find((tag) =>
      tag.kind === "category"
    );
    if (categoryTag == null) {
      throw new Error(`"${property.name}" rule should have \`@category\` tag`);
    }
    const categories = categoryTag.doc.split(",").map((category) =>
      category.trim()
    );
    rules.push({
      name: property.name,
      description,
      categories,
    });
  }
  const markdown = generateMarkdown(rules);
  const path = new URL(import.meta.resolve("../docs/rules.md")).pathname;
  await Deno.writeTextFile(path, markdown);

  const fmtResult = await new Deno.Command("deno", {
    args: [
      "fmt",
      path,
    ],
  }).output();
  if (fmtResult.code !== 0) {
    throw new Error(decoder.decode(fmtResult.stderr));
  }
}

/**
 * @param {Array<LintRule>} rules
 * @returns {string}
 */
function generateMarkdown(rules) {
  /** @type {Record<string, Array<LineRule>>} */
  const rulesByCategory = {};
  for (const rule of rules) {
    for (const category of rule.categories) {
      rulesByCategory[category] ||= [];
      rulesByCategory[category].push(rule);
    }
  }

  const header = `<!-- This file was generated by \`tools/list-rules.js\`. -->
## Rules`;
  const sections = Object.entries(rulesByCategory).map(([category, rules]) => {
    return `### ${category}

|Name|Description|
|:---:|:---:|
${rules.map((rule) => `|\`${rule.name}\`|${rule.description}|`).join("\n")}`;
  });
  return `${header}\n\n${sections.join("\n\n")}`;
}

/**
 * @param {string} s
 * @param {string} prefix
 */
function stripPrefix(s, prefix) {
  if (s.startsWith(prefix)) {
    return s.slice(prefix.length);
  } else {
    return s;
  }
}

if (import.meta.main) {
  main();
}
